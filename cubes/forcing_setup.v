Require Import List.
Require Import String.
Require Import Omega.
Require Import Cubes.axioms
        Cubes.sprop_utils
        Cubes.arith_lemmas
        Cubes.hott_lemmas
        Cubes.cubes
        Cubes.cartesian.

Require Export Template.monad_utils
        Template.Ast
        Template.AstUtils
        Template.Template
        Template.LiftSubst
        Template.Checker
        Template.Typing
        Template.Induction.

Require Export Forcing.TemplateForcing
        Forcing.translation_utils
        Forcing.Inductives.


(** Check that category laws are definitional *)

Theorem compose_assoc {A B C D : nat}
           (f : A ~> B) (g : B ~> C) (h : C ~> D) :
  h √¥ (g √¥ f) = (h √¥ g) √¥ f.
Proof.
  reflexivity.
Qed.

Theorem compose_id_right {A B : nat} (f : A ~> B) :
  f √¥ id = f.
Proof.
  reflexivity.
Qed.

Theorem compose_id_left {A B : nat} (f : A ~> B) :
  id √¥ f = f.
Proof.
  reflexivity.
Qed.





(** Definition of the forcing machinery *)

Definition ùêÇ_obj := nat.
Definition ùêÇ_hom := arrow.
Definition ùêÇ_id := @id.
Definition ùêÇ_comp := @compose.

Quote Definition q_ùêÇ_obj := nat.
Quote Definition q_ùêÇ_hom := arrow.
Quote Definition q_ùêÇ_id := @id.
Quote Definition q_ùêÇ_comp := @compose.

Definition ùêÇ : category :=
  mkCat q_ùêÇ_obj q_ùêÇ_hom q_ùêÇ_id q_ùêÇ_comp.


Import MonadNotation.
Import ListNotations.

Definition ForcingTranslation (cat : category) : Translation :=
  {| tsl_id := tsl_ident;
     tsl_tm := f_translate cat;
     tsl_ty := f_translate_type cat;
     tsl_ind := f_translate_ind cat
     (* tsl_context -> kername -> kername -> mutual_inductive_body *)
     (*             -> tsl_result (tsl_table * list mutual_inductive_body) *)
  |}.

Definition add_translation (ctx : tsl_context) (e : global_reference * term): tsl_context :=
  let (Œ£, E) := ctx in
  (Œ£, e :: E).

Instance Cubical : Translation := ForcingTranslation ùêÇ.

(* Define a type that, when recursively quoted, imports all we need *)
Definition pack := (arrow , @compose , @id).

Run TemplateProgram (prg <- tmQuoteRec pack ;;
                         tmDefinition "g_ctx" (fst prg)).
Definition Œ£E : tsl_context := (reconstruct_global_context g_ctx,[]).



(** Imported inductives *)

(* We copy translated definitions of [eq] generated by the OCaml
   forcing plugin, because inducives are not supported yet by the
   template-coq forcing translation *)
Inductive eq·µó (p : ùêÇ_obj) (A : forall p0 : ùêÇ_obj, p ~> p0 -> forall p : ùêÇ_obj, p0 ~> p -> Type)
(x : forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), A p0 (Œ± √¥ id) p0 id) :
  (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), A p0 (id √¥ (Œ± √¥ id)) p0 id) -> Type :=
  eq_refl·µó : eq·µó p A x x.

(* This definition will fail if we leave the type of [A] implicit. *)
Definition eq_is_eq :
  forall p (A : forall x : ùêÇ_obj, (p ~> x) -> forall x1 : ùêÇ_obj, (x ~> x1) -> Type)
         (x y: forall p0 (f:p ~> p0), A p0 f p0 id),
    eq x y -> eq·µó p A x y. (* it even fails if i don't mention A as an explicit argument
                             here b/c of some mysterious reason *)
Proof.
  intros. rewrite H. apply eq_refl·µó.
Qed.

Run TemplateProgram (TC <- tAddExistingInd Œ£E "Coq.Init.Logic.eq" "eq·µó" ;;
                          tmDefinition "eq_TC" TC).

Inductive False·µó (p : ùêÇ_obj) := .

Run TemplateProgram (TC <- tAddExistingInd eq_TC "Coq.Init.Logic.False" "False·µó" ;;
                        tmDefinition "False_TC" TC).

Inductive or·µó (p : ùêÇ_obj) (A B : forall p0 : ùêÇ_obj, p ~> p0 -> forall p1 : ùêÇ_obj, p0 ~> p1 -> Prop) : Prop :=
    or_introl·µó : (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), A p0 Œ± p0 id) -> or·µó p A B
  | or_intror·µó : (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), B p0 Œ± p0 id) -> or·µó p A B.

Run TemplateProgram (TC <- tAddExistingInd False_TC "Coq.Init.Logic.or" "or·µó" ;;
                        tmDefinition "or_TC" TC).

Inductive and·µó (p : ùêÇ_obj) (A B : forall p0 : ùêÇ_obj, p ~> p0 -> forall p1 : ùêÇ_obj, p0 ~> p1 -> Prop) : Prop :=
    conj·µó : (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), A p0 Œ± p0 id) ->
            (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), B p0 Œ± p0 id) -> and·µó p A B.

Run TemplateProgram (TC <- tAddExistingInd or_TC "Coq.Init.Logic.and" "and·µó" ;;
                        tmDefinition "and_TC" TC).

Inductive sigT·µó (p : ùêÇ_obj)
          (A : forall p0, p ~> p0 -> forall p, p0 ~> p -> Type)
          (P : forall p0 (Œ± : p ~> p0),
              (forall p (Œ±0 : p0 ~> p), A p (Œ±0 √¥ Œ±) p id) ->
              forall p, p0 ~> p -> Type) : Type :=
  existT·µó : forall x : forall p0 (Œ± : p ~> p0), A p0 Œ± p0 id,
    (forall p0 (Œ± : p ~> p0), P p0 Œ± (fun (q : ùêÇ_obj) (Œ±0 : p0 ~> q) => x q (Œ±0 √¥ Œ±)) p0 id) ->
    sigT·µó p A P.

Run TemplateProgram (TC <- tAddExistingInd and_TC "Coq.Init.Specif.sigT" "sigT·µó" ;;
                        tmDefinition "sigT_TC" TC).

Inductive unit·µó (p : ùêÇ_obj) :=
  tt·µó : unit·µó p.

Run TemplateProgram (TC <- tAddExistingInd sigT_TC "Coq.Init.Datatypes.unit" "unit·µó" ;;
                        tmDefinition "unit_TC" TC).

Definition complete_TC := unit_TC.
